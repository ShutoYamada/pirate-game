{"version":3,"sources":["modules/TargetInfo.ts","component/GameBoard.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["TargetInfo","cells","direction","isBroken","GenerateTargets","lines","result","push","GenerateTarget","length","currentTargets","created","row","Math","floor","random","col","duplicate","some","t","find","c","i","GameBoard","props","componentDidMount","reset","setState","targets","selectedCell","onClickCell","Array","from","state","max","aliveShips","filter","alert","findIndex","forEach","allHit","tc","render","isFinished","rows","j","selected","isTarget","icon","className","faWater","faCertificate","faTimes","key","toString","onClick","faShip","faCrosshairs","React","PureComponent","App","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"yUAGqBA,E,sCAEjBC,MAA2C,G,KAE3CC,WAAsB,E,KAEtBC,UAAqB,GAOZC,EAAkB,SAACC,GAC5B,GAAGA,EAAQ,EAAG,MAAO,GACrB,IAAIC,EAAwB,GAO5B,OAJAA,EAAOC,KAAKC,EAAe,EAAEH,EAAOC,IACpCA,EAAOC,KAAKC,EAAe,EAAEH,EAAOC,IACpCA,EAAOC,KAAKC,EAAe,EAAEH,EAAOC,IAE7BA,GASEE,EAAiB,SAACC,EAAiBJ,EAAgBK,GAC5D,IAAIJ,EAAsB,IAAIN,EAC1BW,GAAoB,EACxBD,EAAiBA,GAAkB,GAEnC,IAL4G,iBAOxG,IAAME,EAAeC,KAAKC,MAAMD,KAAKE,SAAUV,GACzCW,EAAeH,KAAKC,MAAMD,KAAKE,SAAUV,GACzCH,EAAqBW,KAAKC,MAAqB,EAAfD,KAAKE,UAI3C,GAHAT,EAAOJ,UAAYA,EAGhBQ,EAAeD,OAAS,EAAE,CACzB,IAAIQ,GAAsB,EAC1B,OAAOf,GAEH,KAAK,EACDe,EAAYP,EAAeQ,MAAK,SAACC,GAC7B,QAASA,EAAElB,MAAMmB,MAAK,SAACC,GAAD,OAAOA,EAAEL,MAAQA,GAAOK,EAAET,KAAOA,EAAMH,QAEjE,MAEJ,KAAK,EACDQ,EAAYP,EAAeQ,MAAK,SAACC,GAC7B,QAASA,EAAElB,MAAMmB,MAAK,SAACC,GAAD,OAAOA,EAAET,MAAQA,GAAOS,EAAEL,KAAOA,EAAMP,QAEjE,MAEJ,KAAK,EACDQ,EAAYP,EAAeQ,MAAK,SAACC,GAC7B,QAASA,EAAElB,MAAMmB,MAAK,SAACC,GAAD,OAAOA,EAAEL,MAAQA,GAAOK,EAAET,KAAOA,EAAMH,QAEjE,MAEJ,KAAK,EACDQ,EAAYP,EAAeQ,MAAK,SAACC,GAC7B,QAASA,EAAElB,MAAMmB,MAAK,SAACC,GAAD,OAAOA,EAAET,MAAQA,GAAOS,EAAEL,KAAOA,EAAMP,QAKzE,GAAGQ,EAAW,iBAIlB,OAAOf,GAEH,KAAK,EACD,GAAGO,GAAUG,EAAI,EAAE,CACfD,GAAU,EACV,IAAI,IAAIW,EAAI,EAAGA,EAAIb,EAAQa,IACvBhB,EAAOL,MAAMM,KAAK,CAAEK,IAAMA,EAAIU,EAAGN,QAGzC,MAEJ,KAAK,EACD,GAAGA,EAAMP,GAAUJ,EAAM,CACrBM,GAAU,EACV,IAAI,IAAIW,EAAI,EAAGA,EAAIb,EAAQa,IACvBhB,EAAOL,MAAMM,KAAK,CAAES,IAAMA,EAAIM,EAAGV,QAGzC,MAEJ,KAAK,EACD,GAAGA,EAAMH,GAAUJ,EAAM,CACrBM,GAAU,EACV,IAAI,IAAIW,EAAI,EAAGA,EAAIb,EAAQa,IACvBhB,EAAOL,MAAMM,KAAK,CAAEK,IAAMA,EAAIU,EAAGN,QAGzC,MAEJ,KAAK,EACD,GAAGP,GAAUO,EAAI,EAAE,CACfL,GAAU,EACV,IAAI,IAAIW,EAAI,EAAGA,EAAIb,EAAQa,IACvBhB,EAAOL,MAAMM,KAAK,CAAES,IAAMA,EAAIM,EAAGV,YA1E9CD,GAAQ,IAiFf,OAAOL,GC8DIiB,E,kDApKX,WAAYC,GAAgB,IAAD,8BACvB,cAAMA,IASVC,kBAAoB,WAAO,IAAD,EACtB,yCAAMC,SAXiB,EAiB3BA,MAAQ,WACJ,EAAKC,SAAS,CACVC,QAAO,YAAOxB,EAAgB,IAC9ByB,aAAe,MApBI,EA6B3BC,YAAc,SAAClB,EAAcI,GACzB,IAAIY,EAAUG,MAAMC,KAAK,EAAKC,MAAML,SAC9BM,EAAM,EAAKD,MAAMC,IACjBL,EAAeE,MAAMC,KAAK,EAAKC,MAAMJ,cACrCM,EAAsBP,EAAQQ,QAAO,SAAAjB,GAAC,OAAKA,EAAEhB,YAAUM,OAChCoB,EAAapB,SAAWyB,GAAsB,IAAfC,EAGxDE,MAAM,wHAKiBR,EAAaS,WAAU,SAACjB,GAAD,OAAOA,EAAET,MAAQA,GAAOS,EAAEL,MAAQA,KACrE,IACXa,EAAatB,KAAK,CAACK,MAAKI,QAM5BY,EAAQW,SAAQ,SAACpB,GACb,IAAGA,EAAEhB,SAAL,CACA,IAAMqC,EAAmBX,EAAaO,QAAO,SAACf,GAC1C,QAAUF,EAAElB,MAAMmB,MAAK,SAACqB,GAAD,OAAQA,EAAG7B,MAAQS,EAAET,KAAO6B,EAAGzB,MAAQK,EAAEL,UACjEP,SAAWU,EAAElB,MAAMQ,OAEtBU,EAAEhB,SAAWqC,MAGjB,EAAKb,SAAS,CACVE,eACAD,cA7DmB,EAiE3Bc,OAAS,WAAO,IAAD,IAE4B,EAAKT,MAApCJ,EAFG,EAEHA,aAAcD,EAFX,EAEWA,QAASM,EAFpB,EAEoBA,IACzBC,EAAsBP,EAAQQ,QAAO,SAAAjB,GAAC,OAAKA,EAAEhB,YAAUM,OACvDkC,EAAuBd,EAAapB,SAAWyB,GAAsB,IAAfC,EAEtD9B,EAAU,EAAKmB,MAAfnB,MACNA,EAAQA,GAAS,EAIjB,IAFA,IAAIuC,EAAuB,GAThB,WAWHtB,GAIJ,IAFA,IAAIrB,EAAwB,GAbrB,WAeC4C,GACJ,IAAMC,EAAqBjB,EAAaX,MAAK,SAACG,GAAD,OAAOA,EAAET,MAAQU,GAAKD,EAAEL,MAAQ6B,KACvEE,EAAqBnB,EAAQV,MAAK,SAACC,GACrC,QAAUA,EAAElB,MAAMmB,MAAK,SAACC,GAAD,OAAOA,EAAET,MAAQU,GAAKD,EAAEL,MAAQ6B,QAIvDG,EACA,kBAAC,IAAD,CAAiBC,UAAU,QAAQD,KAAME,MAI1CJ,IAECE,EAAOD,EACH,kBAAC,IAAD,CAAiBE,UAAU,mBAAmBD,KAAMG,MAEpD,kBAAC,IAAD,CAAiBF,UAAU,aAAaD,KAAMI,OAItDnD,EAAMM,KACF,4BAAQ0C,UAAS,eAAUH,EAAU,WAAa,aAAjC,YAAiDH,GAAcI,EAAU,SAAW,IAC7FM,IAAG,UAAK/B,EAAEgC,WAAP,YAAqBT,EAAES,YAC1BC,QAAS,WAAK,EAAKzB,YAAYR,EAAGuB,KACrCG,KAzBLH,EAAG,EAAGA,EAAIxC,EAAOwC,IAAK,EAAtBA,GA8BRD,EAAKrC,KACD,yBAAK0C,UAAU,MAAMI,IAAG,UAAK/B,EAAEgC,aAC1BrD,KApCLqB,EAAI,EAAGA,EAAIjB,EAAOiB,IAAK,EAAvBA,GAyCR,IAAMhB,EAAuBqC,EACzB,yBAAKM,UAAU,gBACsC,IAA5CrB,EAAQQ,QAAO,SAAAjB,GAAC,OAAKA,EAAEhB,YAAUM,OAC9B,uBAAGwC,UAAU,UAAb,kCAEA,uBAAGA,UAAU,UAAb,2DAGZ,KAEJ,OACI,6BACI,yBAAKA,UAAU,qBACX,0LAA6B,6BAA7B,mKAC8B,6BAD9B,6GAIH3C,EACD,yBAAK2C,UAAU,gBACX,6BACI,kBAAC,IAAD,CAAiBA,UAAU,mBAAmBD,KAAMG,MACpD,kDAEJ,6BACI,kBAAC,IAAD,CAAiBF,UAAU,aAAaD,KAAMI,MAC9C,4CAEJ,6BACI,kBAAC,IAAD,CAAiBH,UAAU,YAAYD,KAAMQ,MAC7C,qCAAO5B,EAAQQ,QAAO,SAAAjB,GAAC,OAAKA,EAAEhB,YAAUM,OAAxC,YAAkDmB,EAAQnB,UAE9D,6BACI,kBAAC,IAAD,CAAiBwC,UAAU,kBAAkBD,KAAMS,MACnD,qCAAOvB,EAAML,EAAapB,OAA1B,YAAoCyB,MAG5C,6BACKU,GAEL,yBAAKK,UAAU,QACX,4BAAQA,UAAU,iBAAiBM,QAAO,6CAAE,EAAM7B,OAAlD,gCA1JZ,EAAKO,MAAQ,CACTJ,aAAe,GACfD,QAAU,GACVM,IAAM,IANa,E,UAFPwB,IAAMC,eCAfC,EAZQ,WAErB,OACE,yBAAKX,UAAU,OACb,4BAAQA,UAAU,cAChB,uBAAGA,UAAU,SAAb,mCAEF,kBAAC,EAAD,QCCcY,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASxB,OACP,kBAAC,IAAMyB,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.8b935f9a.chunk.js","sourcesContent":["/**\n * ターゲットクラス\n */\nexport default class TargetInfo {\n    // 位置情報\n    cells : { row : number, col : number }[] = [];\n    // 向き(0:up, 1:right, 2:down, 3:left)\n    direction : number = -1;\n    // 沈没フラグ\n    isBroken : boolean = false;\n}\n\n/**\n * 指定したマス目内に存在するTargetInfoを生成する\n * @param lines 行数\n */\nexport const GenerateTargets = (lines : number) : TargetInfo[] => {\n    if(lines < 0) return [];\n    let result : TargetInfo[] = [];\n\n    // 長さが3,4,5のTargetInfoを生成する\n    result.push(GenerateTarget(5,lines, result));\n    result.push(GenerateTarget(4,lines, result));\n    result.push(GenerateTarget(3,lines, result));\n\n    return result;\n}\n\n/**\n * TargetInfoを生成\n * @param length 長さ\n * @param lines 行数\n * @param currentTargets 既に生成されているTargetInfoリスト\n */\nexport const GenerateTarget = (length : number, lines : number, currentTargets? : TargetInfo[]) : TargetInfo => {\n    let result : TargetInfo = new TargetInfo();\n    let created : boolean = false;\n    currentTargets = currentTargets || [];\n    \n    while(!created){\n        // ランダムに座標と向きを生成する\n        const row : number = Math.floor(Math.random()*(lines));\n        const col : number = Math.floor(Math.random()*(lines));\n        const direction : number = Math.floor(Math.random()*(4));\n        result.direction = direction;\n\n        // 先に設定されたTargetInfoの座標と被っているかチェック\n        if(currentTargets.length > 0){\n            let duplicate : boolean = false;\n            switch(direction){\n                // up\n                case 0:\n                    duplicate = currentTargets.some((t) => {\n                        return !!t.cells.find((c) => c.col === col && c.row >= row - length)\n                    });\n                    break;\n                // right\n                case 1:\n                    duplicate = currentTargets.some((t) => {\n                        return !!t.cells.find((c) => c.row === row && c.col <= col + length)\n                    });\n                    break;\n                // down\n                case 2:\n                    duplicate = currentTargets.some((t) => {\n                        return !!t.cells.find((c) => c.col === col && c.row <= row + length)\n                    });\n                    break;\n                // left\n                case 3:\n                    duplicate = currentTargets.some((t) => {\n                        return !!t.cells.find((c) => c.row === row && c.col >= col - length)\n                    });\n                    break;\n            }\n\n            if(duplicate) continue;\n        }\n\n        // 生成された座標と向きがマス内に完全に収まるかチェック\n        switch(direction){\n            // up\n            case 0:\n                if(length <= row+1){\n                    created = true;\n                    for(let i = 0; i < length; i++){\n                        result.cells.push({ row : row-i, col })\n                    }\n                } \n                break;\n            // right\n            case 1:\n                if(col + length <= lines){\n                    created = true;\n                    for(let i = 0; i < length; i++){\n                        result.cells.push({ col : col+i, row })\n                    }\n                } \n                break;\n            // down\n            case 2: \n                if(row + length <= lines){\n                    created = true;\n                    for(let i = 0; i < length; i++){\n                        result.cells.push({ row : row+i, col })\n                    }\n                } \n                break;\n            // left\n            case 3:\n                if(length <= col+1){\n                    created = true;\n                    for(let i = 0; i < length; i++){\n                        result.cells.push({ col : col-i, row })\n                    }\n                } \n                break;\n        }\n    }\n\n    return result;\n}","import React from 'react';\nimport './GameBoard.css';\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faShip, faTimes, faCertificate, faCrosshairs, faWater } from \"@fortawesome/free-solid-svg-icons\";\nimport TargetInfo, { GenerateTargets } from '../modules/TargetInfo';\n\ninterface Props {\n    lines? : number,\n}\n\ninterface State {\n    selectedCell : { col : number, row : number }[],\n    targets : TargetInfo[],\n    max : number,\n}\n\nclass GameBoard extends React.PureComponent<Props, State> {\n\n    constructor(props : Props) {\n        super(props);\n\n        this.state = {\n            selectedCell : [],\n            targets : [],\n            max : 24,\n        }\n    }\n\n    componentDidMount = () => {\n        this?.reset();\n    }\n\n    /**\n     * ゲームリセット\n     */\n    reset = () => {\n        this.setState({\n            targets : [...GenerateTargets(8)],\n            selectedCell : [],\n        })\n    }\n\n    /**\n     * セル押下時処理\n     * @param row \n     * @param col \n     */\n    onClickCell = (row : number, col : number) => {\n        let targets = Array.from(this.state.targets);\n        const max = this.state.max;\n        const selectedCell = Array.from(this.state.selectedCell);\n        const aliveShips : number = targets.filter(t => !t.isBroken).length\n        const isFinished : boolean = selectedCell.length === max || aliveShips === 0;\n\n        if(isFinished) {\n            alert('もう一度遊ぶには「リセット」を押してね!!');\n            return\n        };\n\n        // 既に選択済のマスかチェック\n        const findIndex : number = selectedCell.findIndex((c) => c.row === row && c.col === col);\n        if(findIndex < 0){\n            selectedCell.push({row, col});\n        } else {\n            return;\n        }\n\n        // 選択済のマスから大破したターゲットがいるか探索\n        targets.forEach((t) => {\n            if(t.isBroken) return;\n            const allHit : boolean = selectedCell.filter((c) => {\n                return !!(t.cells.find((tc) => tc.row === c.row && tc.col === c.col));\n            }).length === t.cells.length;\n            // 大破の場合はフラグを立てておく\n            t.isBroken = allHit;\n        })\n\n        this.setState({\n            selectedCell,\n            targets\n        })\n    }\n\n    render = () => {\n\n        const { selectedCell, targets, max } = this.state;\n        const aliveShips : number = targets.filter(t => !t.isBroken).length\n        const isFinished : boolean = selectedCell.length === max || aliveShips === 0;\n\n        let { lines } = this.props;\n        lines = lines || 8;\n\n        let rows : JSX.Element[] = [];\n\n        for(let i = 0; i < lines; i++){\n\n            let cells : JSX.Element[] = [];\n\n            for(let j= 0; j < lines; j++){\n                const selected : boolean = selectedCell.some((c) => c.row === i && c.col === j);\n                const isTarget : boolean = targets.some((t) => {\n                    return !!(t.cells.find((c) => c.row === i && c.col === j));\n                });\n\n                // デフォルトでは透明アイコンを表示\n                let icon : JSX.Element = (\n                    <FontAwesomeIcon className='water' icon={faWater} />\n                );\n\n                // もし選択されたマスなら\n                if(selected){\n                    // ターゲットの有無で表示するアイコンを変更\n                    icon = isTarget? (\n                        <FontAwesomeIcon className='icon certificate' icon={faCertificate} />\n                    ) : (\n                        <FontAwesomeIcon className='icon times' icon={faTimes} />\n                    )\n                }\n\n                cells.push(\n                    <button className={`cell ${selected? 'selected' : 'unselected'} ${isFinished && isTarget? 'target' : ''}`} \n                            key={`${i.toString()}_${j.toString()}`} \n                            onClick={()=>{this.onClickCell(i, j)}}>\n                        {icon}\n                    </button>\n                )\n            }\n\n            rows.push(\n                <div className=\"row\" key={`${i.toString()}`}>\n                    {cells}\n                </div>\n            )\n        }\n\n        const result : JSX.Element = isFinished? (\n            <div className=\"status inset\">\n                    {targets.filter(t => !t.isBroken).length === 0? (\n                        <p className='result'>完全勝利！</p>\n                    ) : (\n                        <p className='result'>残念！また遊んでね</p>\n                    )}\n            </div>\n        ) : null;\n\n        return (\n            <div>\n                <div className=\"description inset\">\n                    <p>下記のマスの中に隠れている海賊船を大砲で撃沈しよう！<br/>\n                    海賊船は3隻で、船体の長さはそれぞれ3マス、4マス、5マス。<br/>\n                    大砲の弾は最大24発まで発射できます。</p>\n                </div>\n                {result}\n                <div className=\"status inset\"> \n                    <div>\n                        <FontAwesomeIcon className='icon certificate' icon={faCertificate} />\n                        <p>当たり</p>\n                    </div>\n                    <div>\n                        <FontAwesomeIcon className='icon times' icon={faTimes} />\n                        <p>外れ</p>\n                    </div>\n                    <div>\n                        <FontAwesomeIcon className='icon ship' icon={faShip} />\n                        <p>{`${targets.filter(t => !t.isBroken).length}/${targets.length}`}</p>\n                    </div>\n                    <div>\n                        <FontAwesomeIcon className='icon crosshairs' icon={faCrosshairs} />\n                        <p>{`${max - selectedCell.length}/${max}`}</p>\n                    </div>\n                </div>\n                <div>\n                    {rows}\n                </div>\n                <div className=\"menu\">\n                    <button className=\"neumorphic-btn\" onClick={this?.reset} >リセット</button>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default GameBoard;\n","import React from 'react';\nimport './App.css';\nimport GameBoard from './component/GameBoard';\n\nconst App : React.FC = () => {\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <p className=\"title\">海戦ゲーム</p>\n      </header>\n      <GameBoard />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}